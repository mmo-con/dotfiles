#ifndef BOARD_H
#define BOARD_H


#include "globs.h"
#include "bit_board.h"


#ifdef DEBUG
#define DLOG(file_, func_, line_, msg_)\
do {\
    fprintf (stderr, "In [%s, %s] at line %d:\n", (file_), (func_), (line_));\
    fprintf (stderr, "\t%s\n", (msg_));\
} while (false);
#else
#define DLOG(file_, func_, line_, msg_)
#endif


#define BOARD_SIZE       64
#define BOARD_SIZE_EXT  120
#define MAX_HALFMOVES  2048

#define SQ_64_TO_120(row_, col_) (21 + (col_) + 10 * (row_))
#define PIECE_CHECK_BIT(piece_, index_) ((piece_) & (1ULL << (index_)))


typedef enum color_tag
{
    WHITE = 0,
    BLACK,

} color_t;


/* Constants for the control of castle permissions */
/* ----------------------------------------------- */
typedef enum castle_tag
{
    CASTLE_WK  = 1, /* White king castle  */
    CASTLE_WQ  = 2, /* White queen castle */
    CASTLE_BK  = 4, /* Black king castle  */
    CASTLE_BQ  = 8, /* Black queen castle */
    CASTLE_ALL = 15 /* All castle-permissions (for init purposes) */

} castle_t;


/* Constants for the Rows and Columns of the norm board */
/* ---------------------------------------------------- */
enum {ROW_1, ROW_2, ROW_3, ROW_4, ROW_5, ROW_6, ROW_7, ROW_8};
enum {COL_A, COL_B, COL_C, COL_D, COL_E, COL_F, COL_G, COL_H};


/* Classical chessboard square naming for better readability */
/* --------------------------------------------------------- */
enum {A1 = 21, B1, C1, D1, E1, F1, G1, H1,
      A2 = 31, B2, C2, D2, E2, F2, G2, H2,
      A3 = 41, B3, C3, D3, E3, F3, G3, H3,
      A4 = 51, B4, C4, D4, E4, F4, G4, H4,
      A5 = 61, B5, C5, D5, E5, F5, G5, H5,
      A6 = 71, B6, C6, D6, E6, F6, G6, H6,
      A7 = 81, B7, C7, D7, E7, F7, G7, H7,
      A8 = 91, B8, C8, D8, E8, F8, G8, H8, OFF_BOARD};


/* Structure for take-back housekeeping */
/* ------------------------------------ */
typedef struct hash_tag
{
    color_t  side;
    castle_t castle;
    square_t en_passant;
    uint16   draw_50;
    uint64   board_hash;

} hash_t;


typedef struct bit_board_tag
{
    uint64 king[2];
    uint64 queen[2];
    uint64 rook[2];
    uint64 knight[2];
    uint64 bishop[2];
    uint64 pawn[2];

} bit_board_t;


typedef struct board_tag
{
    square_t    squares_120[BOARD_SIZE_EXT];  /* The extended board               */
    square_t    sq_120_to_64[BOARD_SIZE_EXT]; /* Mapping from ext to norm board   */
    square_t    sq_64_to_120[BOARD_SIZE];     /* Mapping from norm to ext board   */
    color_t     side;                         /* Which side is to move?           */
    castle_t    castle;                       /* Castle permissions               */
    square_t    en_passant;                   /* Possible 'en passant' square     */
    uint16      draw_50;                      /* Counter for 50 moves draw rule   */
    uint16      hm_history;                   /* Number of halfmoves done overall */
    uint64      board_hash;                   /* Hash value for the current posit */
    hash_t      history[MAX_HALFMOVES];       /* Game history for take back       */
    bit_board_t bit_board;                    /* 64 Bit representation of squares */
                                              /* occupied by each piece-type      */

} board_t;


bool generate_board_mappings (board_t *board);
bool generate_hash_value (board_t *board);
bool init_board (board_t *board);


#endif
